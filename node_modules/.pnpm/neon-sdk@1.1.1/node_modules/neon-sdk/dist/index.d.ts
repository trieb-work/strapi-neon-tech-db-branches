type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

declare class CancelError extends Error {
    constructor(message: string);
    get isCancelled(): boolean;
}
interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    readonly [Symbol.toStringTag]: string;
    private _isResolved;
    private _isRejected;
    private _isCancelled;
    private readonly _cancelHandlers;
    private readonly _promise;
    private _resolve?;
    private _reject?;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;
type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
    ENCODE_PATH?: (path: string) => string;
};
declare const OpenAPI: OpenAPIConfig;

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

type ApiKeyCreateRequest = {
    /**
     * A user-specified API key name. This value is required when creating an API key.
     */
    key_name: string;
};

type ApiKeyCreateResponse = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The generated 64-bit token required to access the Neon API
     */
    key: string;
};

type ApiKeyRevokeResponse = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A `true` or `false` value indicating whether the API key is revoked
     */
    revoked: boolean;
    /**
     * A timestamp indicating when the API was last used
     */
    last_used_at?: string | null;
    /**
     * The IP address from which the API key was last used
     */
    last_used_from_addr: string;
};

type ApiKeysListResponseItem = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A timestamp indicating when the API key was created
     */
    created_at: string;
    /**
     * A timestamp indicating when the API was last used
     */
    last_used_at?: string | null;
    /**
     * The IP address from which the API key was last used
     */
    last_used_from_addr: string;
};

type ErrorCode = string;

/**
 * General Error
 */
type GeneralError = {
    code: ErrorCode;
    /**
     * Description of error that happened
     */
    message: string;
};

declare class ApiKeyService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get a list of API keys
     * Retrieves the API keys for your Neon account.
     * The response does not include API key tokens. A token is only provided when creating an API key.
     * API keys can also be managed in the Neon Console.
     * For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
     *
     * @returns ApiKeysListResponseItem Returned the API keys for the Neon account
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listApiKeys(): CancelablePromise<Array<ApiKeysListResponseItem> | GeneralError>;
    /**
     * Create an API key
     * Creates an API key.
     * The `key_name` is a user-specified name for the key.
     * This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API.
     * API keys can also be managed in the Neon Console.
     * See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
     *
     * @param requestBody
     * @returns ApiKeyCreateResponse Created an API key
     * @returns GeneralError General Error
     * @throws ApiError
     */
    createApiKey(requestBody: ApiKeyCreateRequest): CancelablePromise<ApiKeyCreateResponse | GeneralError>;
    /**
     * Revoke an API key
     * Revokes the specified API key.
     * An API key that is no longer needed can be revoked.
     * This action cannot be reversed.
     * You can obtain `key_id` values by listing the API keys for your Neon account.
     * API keys can also be managed in the Neon Console.
     * See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
     *
     * @param keyId The API key ID
     * @returns ApiKeyRevokeResponse Revoked the specified API key
     * @returns GeneralError General Error
     * @throws ApiError
     */
    revokeApiKey(keyId: number): CancelablePromise<ApiKeyRevokeResponse | GeneralError>;
}

/**
 * Endpoint type. Either "read_write" for read-write primary or "read_only" for read-only secondary.
 * "read_only" endpoints are not yet implemented.
 *
 */
type EndpointType = 'read_only' | 'read_write';

type BranchCreateRequestEndpointOptions = {
    type: EndpointType;
    autoscaling_limit_min_cu?: number;
    autoscaling_limit_max_cu?: number;
};

type BranchCreateRequest = {
    endpoints?: Array<BranchCreateRequestEndpointOptions>;
    branch?: {
        parent_id?: string;
        name?: string;
        parent_lsn?: string;
        parent_timestamp?: string;
    };
};

type BranchState = 'init' | 'ready';

type Branch = {
    id: string;
    project_id: string;
    parent_id?: string;
    parent_lsn?: string;
    parent_timestamp?: string;
    name: string;
    current_state: BranchState;
    pending_state?: BranchState;
    /**
     * Branch logical size in bytes
     */
    logical_size?: number;
    /**
     * Branch physical size in bytes
     */
    physical_size?: number;
    creation_source: string;
    primary: boolean;
    created_at: string;
    updated_at: string;
};

type BranchesResponse = {
    branches: Array<Branch>;
};

type BranchResponse = {
    branch: Branch;
};

type OperationAction = 'create_compute' | 'create_timeline' | 'start_compute' | 'suspend_compute' | 'apply_config' | 'check_availability' | 'delete_timeline' | 'create_branch' | 'tenant_migrate' | 'tenant_detach' | 'tenant_reattach' | 'replace_safekeeper';

type OperationStatus = 'running' | 'finished' | 'failed' | 'scheduling';

type Operation = {
    id: string;
    project_id: string;
    branch_id?: string;
    endpoint_id?: string;
    action: OperationAction;
    status: OperationStatus;
    error?: string;
    failures_count: number;
    retry_at?: string;
    created_at: string;
    updated_at: string;
};

type OperationsResponse = {
    operations: Array<Operation>;
};

type BranchOperations = (BranchResponse & OperationsResponse);

type BranchUpdateRequest = {
    branch: {
        name?: string;
    };
};

type ConnectionURI = {
    /**
     * Connection URI is same as specified in https://www.postgresql.org/docs/current/libpq-connect.html#id-1.7.3.8.3.6
     * It is a ready to use string for psql or for DATABASE_URL environment variable.
     *
     */
    connection_uri: string;
};

type ConnectionURIsResponse = {
    connection_uris: Array<ConnectionURI>;
};

type DatabaseCreateRequest = {
    database: {
        name: string;
        owner_name: string;
    };
};

type Database = {
    id: number;
    branch_id: string;
    name: string;
    owner_name: string;
    created_at: string;
    updated_at: string;
};

type DatabaseResponse = {
    database: Database;
};

type DatabaseOperations = (DatabaseResponse & OperationsResponse);

type DatabasesResponse = {
    databases: Array<Database>;
};

type DatabaseUpdateRequest = {
    database: {
        name?: string;
        owner_name?: string;
    };
};

type EndpointPoolerMode = 'transaction';

/**
 * PgSettingsData is a raw representation of Postgres settings
 */
type PgSettingsData = Record<string, string>;

/**
 * Endpoint settings is a collection of settings for an Endpoint
 */
type EndpointSettingsData = {
    pg_settings?: PgSettingsData;
};

type EndpointState = 'init' | 'active' | 'idle';

type Endpoint = {
    /**
     * Hostname to connect to.
     *
     */
    host: string;
    id: string;
    project_id: string;
    branch_id: string;
    autoscaling_limit_min_cu: number;
    autoscaling_limit_max_cu: number;
    region_id: string;
    type: EndpointType;
    current_state: EndpointState;
    pending_state?: EndpointState;
    settings: EndpointSettingsData;
    /**
     * Enable or disable connection pooling for this endpoint.
     */
    pooler_enabled: boolean;
    pooler_mode: EndpointPoolerMode;
    /**
     * Restrict any connections to this endpoint.
     */
    disabled: boolean;
    /**
     * Allow or restrict passwordless access to this endpoint.
     */
    passwordless_access: boolean;
    /**
     * Timestamp of the last detected activity of the endpoint.
     */
    last_active?: string;
    creation_source: string;
    created_at: string;
    updated_at: string;
    /**
     * DEPRECATED. Use the "host" property instead.
     *
     */
    proxy_host: string;
};

type EndpointsResponse = {
    endpoints: Array<Endpoint>;
};

type RoleCreateRequest = {
    role: {
        name: string;
    };
};

type Role = {
    branch_id: string;
    name: string;
    password?: string;
    protected?: boolean;
    created_at: string;
    updated_at: string;
};

type RoleResponse = {
    role: Role;
};

type RoleOperations = (RoleResponse & OperationsResponse);

type RolePasswordResponse = {
    password: string;
};

type RolesResponse = {
    roles: Array<Role>;
};

declare class BranchService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Create a branch
     * Creates a branch in the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * This method does not require a request body, but you can specify one to create an endpoint for the branch or to select a non-default parent branch.
     * The default behavior is to create a branch from the project's root branch (`main`) with no endpoint, and the branch name is auto-generated.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns any Created a branch. An endpoint is only created if it was specified in the request.
     * @throws ApiError
     */
    createProjectBranch(projectId: string, requestBody?: BranchCreateRequest): CancelablePromise<GeneralError | (BranchResponse & EndpointsResponse & OperationsResponse & ConnectionURIsResponse)>;
    /**
     * Get a list of branches
     * Retrieves a list of branches for the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * Each Neon project has a root branch named `main`.
     * A `branch_id` value has a `br-` prefix.
     * A project may contain child branches that were branched from `main` or from another branch.
     * A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @returns BranchesResponse Returned a list of branches for the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranches(projectId: string): CancelablePromise<BranchesResponse | GeneralError>;
    /**
     * Get branch details
     * Retrieves information about the specified branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain a `branch_id` by listing the project's branches.
     * A `branch_id` value has a `br-` prefix.
     *
     * Each Neon project has a root branch named `main`.
     * A project may contain child branches that were branched from `main` or from another branch.
     * A parent branch is identified by a `parent_id` value, which is the `id` of the parent branch.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns BranchResponse Returned information about the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranch(projectId: string, branchId: string): CancelablePromise<BranchResponse | GeneralError>;
    /**
     * Delete a branch
     * Deletes the specified branch from a project, and places
     * all endpoints into an idle state, breaking existing client connections.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain a `branch_id` by listing the project's branches.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * When a successful response status is received, the endpoints are still active,
     * and the branch is not yet deleted from storage.
     * The deletion occurs after all operations finish.
     * You cannot delete a branch if it is the only remaining branch in the project.
     * A project must have at least one branch.
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns BranchOperations Deleted the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectBranch(projectId: string, branchId: string): CancelablePromise<BranchOperations | GeneralError>;
    /**
     * Update a branch
     * Updates the specified branch. Only changing the branch name is supported.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param requestBody
     * @returns BranchOperations Updated the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProjectBranch(projectId: string, branchId: string, requestBody: BranchUpdateRequest): CancelablePromise<BranchOperations | GeneralError>;
    /**
     * Set the branch as the primary branch of a project
     * The primary mark is automatically removed from the previous primary branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns BranchOperations Updated the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    setPrimaryProjectBranch(projectId: string, branchId: string): CancelablePromise<BranchOperations | GeneralError>;
    /**
     * Get a list of branch endpoints
     * Retrieves a list of endpoints for the specified branch.
     * Currently, Neon permits only one endpoint per branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns EndpointsResponse Returned a list of endpoints for the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranchEndpoints(projectId: string, branchId: string): CancelablePromise<EndpointsResponse | GeneralError>;
    /**
     * Get a list of databases
     * Retrieves a list of databases for the specified branch.
     * A branch can have multiple databases.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns DatabasesResponse Returned a list of databases of the specified branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranchDatabases(projectId: string, branchId: string): CancelablePromise<DatabasesResponse | GeneralError>;
    /**
     * Create a database
     * Creates a database in the specified branch.
     * A branch can have multiple databases.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns DatabaseOperations Created a database in the specified branch
     * @throws ApiError
     */
    createProjectBranchDatabase(projectId: string, branchId: string, requestBody: DatabaseCreateRequest): CancelablePromise<GeneralError | DatabaseOperations>;
    /**
     * Get database details
     * Retrieves information about the specified database.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` and `database_name` by listing branch's databases.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param databaseName The database name
     * @returns DatabaseResponse Returned the database details
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranchDatabase(projectId: string, branchId: string, databaseName: string): CancelablePromise<DatabaseResponse | GeneralError>;
    /**
     * Update a database
     * Updates the specified database in the branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` and `database_name` by listing the branch's databases.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param databaseName The database name
     * @param requestBody
     * @returns DatabaseOperations Updated the database
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProjectBranchDatabase(projectId: string, branchId: string, databaseName: string, requestBody: DatabaseUpdateRequest): CancelablePromise<DatabaseOperations | GeneralError>;
    /**
     * Delete a database
     * Deletes the specified database from the branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` and `database_name` by listing branch's databases.
     * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param databaseName The database name
     * @returns DatabaseOperations Deleted the specified database
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectBranchDatabase(projectId: string, branchId: string, databaseName: string): CancelablePromise<DatabaseOperations | GeneralError>;
    /**
     * Get a list of roles
     * Retrieves a list of roles from the specified branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Manage users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @returns RolesResponse Returned a list of roles from the specified branch.
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranchRoles(projectId: string, branchId: string): CancelablePromise<RolesResponse | GeneralError>;
    /**
     * Create a role
     * Creates a role in the specified branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Manage users](https://neon.tech/docs/manage/users/).
     *
     * Connections established to the active read-write endpoint will be dropped.
     * If the read-write endpoint is idle, the endpoint becomes active for a short period of time and is suspended afterward.
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns RoleOperations Created a role in the specified branch
     * @throws ApiError
     */
    createProjectBranchRole(projectId: string, branchId: string, requestBody: RoleCreateRequest): CancelablePromise<GeneralError | RoleOperations>;
    /**
     * Get role details
     * Retrieves details about the specified role.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role name
     * @returns RoleResponse Successfully returned details for the specified role
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranchRole(projectId: string, branchId: string, roleName: string): CancelablePromise<RoleResponse | GeneralError>;
    /**
     * Delete a role
     * Deletes the specified role from the branch.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role name
     * @returns RoleOperations Deleted the specified role from the branch
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectBranchRole(projectId: string, branchId: string, roleName: string): CancelablePromise<RoleOperations | GeneralError>;
    /**
     * Get role password
     * Retrieves password of the specified role if possible.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role name
     * @returns RolePasswordResponse Successfully returned password for the specified role
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectBranchRolePassword(projectId: string, branchId: string, roleName: string): CancelablePromise<RolePasswordResponse | GeneralError>;
    /**
     * Reset the role password
     * Resets the password for the specified role.
     * Returns a new password and operations. The new password is ready to use when the last operation finishes.
     * The old password remains valid until last operation finishes.
     * Connections to the read-write endpoint are dropped. If idle,
     * the read-write endpoint becomes active for a short period of time.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain the `branch_id` by listing the project's branches.
     * You can obtain the `role_name` by listing the roles for a branch.
     * In Neon, the terms "role" and "user" are synonymous.
     * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
     *
     * @param projectId The Neon project ID
     * @param branchId The branch ID
     * @param roleName The role nam
     * @returns RoleOperations Reset the passsword for the specified role
     * @returns GeneralError General Error
     * @throws ApiError
     */
    resetProjectBranchRolePassword(projectId: string, branchId: string, roleName: string): CancelablePromise<RoleOperations | GeneralError>;
}

type EndpointCreateRequest = {
    endpoint: {
        branch_id: string;
        /**
         * Only the project region_id is allowed for now
         *
         */
        region_id?: string;
        type: EndpointType;
        settings?: EndpointSettingsData;
        autoscaling_limit_min_cu?: number;
        autoscaling_limit_max_cu?: number;
        pooler_enabled?: boolean;
        pooler_mode?: EndpointPoolerMode;
        /**
         * Restrict any connections to this endpoint.
         */
        disabled?: boolean;
        /**
         * NOT IMPLEMENTED YET
         *
         */
        passwordless_access?: boolean;
    };
};

type EndpointResponse = {
    endpoint: Endpoint;
};

type EndpointOperations = (EndpointResponse & OperationsResponse);

type EndpointUpdateRequest = {
    endpoint: {
        /**
         * Destination branch identifier. The destination branch must not have an exsiting read-write endpoint.
         *
         */
        branch_id?: string;
        autoscaling_limit_min_cu?: number;
        autoscaling_limit_max_cu?: number;
        settings?: EndpointSettingsData;
        pooler_enabled?: boolean;
        pooler_mode?: EndpointPoolerMode;
        /**
         * Restrict any connections to this endpoint.
         */
        disabled?: boolean;
        /**
         * NOT IMPLEMENTED YET
         *
         */
        passwordless_access?: boolean;
    };
};

declare class EndpointService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Create an endpoint
     * Creates an endpoint for the specified branch.
     * An endpoint is a Neon compute instance.
     * There is a maximum of one endpoint per branch.
     * If the specified branch already has an endpoint, the operation fails.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain `branch_id` by listing the project's branches.
     * A `branch_id` has a `br-` prefix.
     * Currently, only the `read_write` endpoint type is supported.
     * For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns EndpointOperations Created an endpoint
     * @throws ApiError
     */
    createProjectEndpoint(projectId: string, requestBody: EndpointCreateRequest): CancelablePromise<GeneralError | EndpointOperations>;
    /**
     * Get a list of endpoints
     * Retrieves a list of endpoints for the specified project.
     * An endpoint is a Neon compute instance.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @returns EndpointsResponse Returned a list of endpoints for the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectEndpoints(projectId: string): CancelablePromise<EndpointsResponse | GeneralError>;
    /**
     * Get an endpoint
     * Retrieves information about the specified endpoint.
     * An endpoint is a Neon compute instance.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointResponse Returned information about the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointResponse | GeneralError>;
    /**
     * Delete an endpoint
     * Delete the specified endpoint.
     * An endpoint is a Neon compute instance.
     * Deleting an endpoint drops existing network connections to the endpoint.
     * The deletion is completed when last operation in the chain finishes successfully.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointOperations Deleted the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointOperations | GeneralError>;
    /**
     * Update an endpoint
     * Updates the specified endpoint. Currently, only changing the associated branch is supported.
     * The branch that you specify cannot have an existing endpoint.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` and `branch_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix. A `branch_id` has a `br-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * If the returned list of operations is not empty, the endpoint is not ready to use.
     * The client must wait for the last operation to finish before using the endpoint.
     * If the endpoint was idle before the update, the endpoint becomes active for a short period of time,
     * and the control plane suspends it again after the update.
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @param requestBody
     * @returns EndpointOperations Updated the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProjectEndpoint(projectId: string, endpointId: string, requestBody: EndpointUpdateRequest): CancelablePromise<EndpointOperations | GeneralError>;
    /**
     * Start an endpoint
     * Starts an endpoint. The endpoint is ready to use
     * after the last operation in chain finishes successfully.
     *
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointOperations Started the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    startProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointOperations | GeneralError>;
    /**
     * Suspend an endpoint
     * Suspend the specified endpoint
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain an `endpoint_id` by listing your project's endpoints.
     * An `endpoint_id` has an `ep-` prefix.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @param endpointId The endpoint ID
     * @returns EndpointOperations Suspended the specified endpoint
     * @returns GeneralError General Error
     * @throws ApiError
     */
    suspendProjectEndpoint(projectId: string, endpointId: string): CancelablePromise<EndpointOperations | GeneralError>;
}

type OperationResponse = {
    operation: Operation;
};

/**
 * Cursor based pagination is used. The user must pass the cursor as is to the backend.
 * For more information about cursor based pagination, see
 * https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
 *
 */
type Pagination = {
    cursor: string;
};

type PaginationResponse = {
    pagination?: Pagination;
};

declare class OperationService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get operation details
     * Retrieves details for the specified operation.
     * An operation is an action performed on a Neon project resource.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * You can obtain a `operation_id` by listing operations for the project.
     *
     * @param projectId The Neon project ID
     * @param operationId The operation ID
     * @returns OperationResponse Returned details for the specified operation
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProjectOperation(projectId: string, operationId: string): CancelablePromise<OperationResponse | GeneralError>;
    /**
     * Get a list of operations
     * Retrieves a list of operations for the specified Neon project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * The number of operations returned can be large.
     * To paginate the response, issue an initial request with a `limit` value.
     * Then, add the `cursor` value that was returned in the response to the next request.
     *
     * @param projectId The Neon project ID
     * @param cursor Specify the cursor value from the previous response to get the next batch of operations
     * @param limit Specify a value from 1 to 1000 to limit number of operations in the response
     * @returns any Returned a list of operations
     *
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectOperations(projectId: string, cursor?: string, limit?: number): CancelablePromise<(OperationsResponse & PaginationResponse) | GeneralError>;
}

/**
 * Major version of the Postgres
 */
type PgVersion = number;

/**
 * The consumption quota of a project.
 * After the quota has been exceeded, it is impossible to use the project until either:
 * * Neon cloud resets the calculated consumption,
 * * or the user increases quota for the project.
 * The Neon cloud resets the quota in the beginning of the billing period.
 *
 * If the quota is not set, the project can use as many resources as needed.
 *
 */
type ProjectSettingsQuota = {
    /**
     * The total amount of CPU seconds allowed to be spent by the endpoints of the project.
     *
     */
    cpu_quota_sec?: number;
};

type ProjectSettings = {
    quota?: ProjectSettingsQuota;
};

type ProjectCreateRequest = {
    project: {
        settings?: ProjectSettings;
        name?: string;
        autoscaling_limit_min_cu?: number;
        autoscaling_limit_max_cu?: number;
        provisioner?: 'k8s-pod' | 'k8s-neonvm' | 'docker';
        region_id?: string;
        default_endpoint_settings?: PgSettingsData;
        pg_version?: PgVersion;
        store_passwords?: boolean;
    };
};

/**
 * ProjectSettingsData is a collection of settings for a Project
 */
type ProjectSettingsData = {
    pg_settings?: PgSettingsData;
};

type Project = {
    id: string;
    platform_id: string;
    region_id: string;
    name: string;
    provisioner?: 'k8s-pod' | 'k8s-neonvm' | 'docker';
    default_endpoint_settings?: ProjectSettingsData;
    settings?: ProjectSettings;
    pg_version: PgVersion;
    proxy_host: string;
    /**
     * Value is in MiB.
     *
     */
    branch_logical_size_limit: number;
    store_passwords: boolean;
    /**
     * CPU seconds used by all the endpoints of the project, including deleted ones.
     * This value is reset at the beginning of each billing period.
     * Examples:
     * 1. An endpoint that uses 1 CPU for 1 second is equal to `cpu_used_sec=1`.
     * 2. An endpoint that uses 2 CPUs simultaneously for 1 second is equal to `cpu_used_sec=2`.
     *
     */
    cpu_used_sec: number;
    /**
     * If set, the project will be in maintenance mode from that time.
     *
     */
    maintenance_starts_at?: string;
    creation_source: string;
    created_at: string;
    updated_at: string;
    /**
     * Experimental. Do not use this field yet!
     * Data storage size in bytes.
     *
     */
    synthetic_storage_size?: number;
    quota_reset_at?: string;
};

type ProjectResponse = {
    project: Project;
};

type ProjectOperations = (ProjectResponse & OperationsResponse);

type ProjectsResponse = {
    projects: Array<Project>;
};

type ProjectUpdateRequest = {
    project: {
        settings?: ProjectSettings;
        name?: string;
        default_endpoint_settings?: PgSettingsData;
    };
};

declare class ProjectService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get a list of projects
     * Retrieves a list of projects for the Neon account.
     * A project is the top-level object in the Neon object hierarchy.
     * For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
     *
     * @param cursor Specify the cursor value from the previous response to get the next batch of projects.
     * @param limit Specify a value from 1 to 100 to limit number of projects in the response.
     * @returns any Returned a list of projects for the Neon account
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjects(cursor?: string, limit?: number): CancelablePromise<(ProjectsResponse & PaginationResponse) | GeneralError>;
    /**
     * Create a project
     * Creates a Neon project.
     * A project is the top-level object in the Neon object hierarchy.
     * Tier limits define how many projects you can create.
     * Neon's Free Tier permits one project per Neon account.
     * For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
     *
     * You can specify a region and PostgreSQL version in the request body.
     * Neon currently supports PostgreSQL 14 and 15.
     * For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
     *
     * @param requestBody
     * @returns GeneralError General Error
     * @returns any Created a project.
     * The project includes a connection URI with a database, password, and role.
     * At least one non-protected role is created with a password.
     * Wait until the operations are finished before attempting to connect to a project database.
     *
     * @throws ApiError
     */
    createProject(requestBody: ProjectCreateRequest): CancelablePromise<GeneralError | (ProjectResponse & ConnectionURIsResponse & RolesResponse & DatabasesResponse & OperationsResponse & BranchResponse & EndpointsResponse)>;
    /**
     * Get project details
     * Retrieves information about the specified project.
     * A project is the top-level object in the Neon object hierarchy.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * @param projectId The Neon project ID
     * @returns ProjectResponse Returned information about the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    getProject(projectId: string): CancelablePromise<ProjectResponse | GeneralError>;
    /**
     * Update a project
     * Updates the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * Neon permits updating the project name only.
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns ProjectOperations Updated the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    updateProject(projectId: string, requestBody: ProjectUpdateRequest): CancelablePromise<ProjectOperations | GeneralError>;
    /**
     * Delete a project
     * Deletes the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * Deleting a project is a permanent action.
     * Deleting a project also deletes endpoints, branches, databases, and users that belong to the project.
     *
     * @param projectId The Neon project ID
     * @returns ProjectResponse Deleted the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    deleteProject(projectId: string): CancelablePromise<ProjectResponse | GeneralError>;
    /**
     * Get a list of operations
     * Retrieves a list of operations for the specified Neon project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * The number of operations returned can be large.
     * To paginate the response, issue an initial request with a `limit` value.
     * Then, add the `cursor` value that was returned in the response to the next request.
     *
     * @param projectId The Neon project ID
     * @param cursor Specify the cursor value from the previous response to get the next batch of operations
     * @param limit Specify a value from 1 to 1000 to limit number of operations in the response
     * @returns any Returned a list of operations
     *
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectOperations(projectId: string, cursor?: string, limit?: number): CancelablePromise<(OperationsResponse & PaginationResponse) | GeneralError>;
    /**
     * Create a branch
     * Creates a branch in the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * This method does not require a request body, but you can specify one to create an endpoint for the branch or to select a non-default parent branch.
     * The default behavior is to create a branch from the project's root branch (`main`) with no endpoint, and the branch name is auto-generated.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @param requestBody
     * @returns GeneralError General Error
     * @returns any Created a branch. An endpoint is only created if it was specified in the request.
     * @throws ApiError
     */
    createProjectBranch(projectId: string, requestBody?: BranchCreateRequest): CancelablePromise<GeneralError | (BranchResponse & EndpointsResponse & OperationsResponse & ConnectionURIsResponse)>;
    /**
     * Get a list of branches
     * Retrieves a list of branches for the specified project.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     *
     * Each Neon project has a root branch named `main`.
     * A `branch_id` value has a `br-` prefix.
     * A project may contain child branches that were branched from `main` or from another branch.
     * A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch.
     * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
     *
     * @param projectId The Neon project ID
     * @returns BranchesResponse Returned a list of branches for the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectBranches(projectId: string): CancelablePromise<BranchesResponse | GeneralError>;
    /**
     * Get a list of endpoints
     * Retrieves a list of endpoints for the specified project.
     * An endpoint is a Neon compute instance.
     * You can obtain a `project_id` by listing the projects for your Neon account.
     * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
     *
     * @param projectId The Neon project ID
     * @returns EndpointsResponse Returned a list of endpoints for the specified project
     * @returns GeneralError General Error
     * @throws ApiError
     */
    listProjectEndpoints(projectId: string): CancelablePromise<EndpointsResponse | GeneralError>;
}

type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;
declare class NeonClient {
    readonly apiKey: ApiKeyService;
    readonly branch: BranchService;
    readonly endpoint: EndpointService;
    readonly operation: OperationService;
    readonly project: ProjectService;
    readonly request: BaseHttpRequest;
    constructor(config?: Partial<OpenAPIConfig>, HttpRequest?: HttpRequestConstructor);
}

type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};

declare class ApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
    readonly request: ApiRequestOptions;
    constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}

type ConnectionURIResponse = {
    connection_uri: ConnectionURI;
};

type ConsoleSettingsRaw = {
    /**
     * management
     */
    project_creation_forbidden?: boolean;
    proxy_host?: string;
};

type CurrentUserAuthAccount = {
    email: string;
    image: string;
    login: string;
    name: string;
    provider: string;
};

type CurrentUserInfoResponse = {
    auth_accounts: Array<CurrentUserAuthAccount>;
    email: string;
    id: string;
    image: string;
    login: string;
    name: string;
    projects_limit: number;
    endpoints_limit: number;
    branches_limit: number;
    max_autoscaling_limit: number;
    compute_seconds_limit: number;
};

/**
 * A Duration represents the elapsed time between two instants
 * as an int64 nanosecond count. The representation limits the
 * largest representable duration to approximately 290 years.
 */
type Duration = number;

/**
 * Empty response.
 */
type EmptyResponse = {};

type EndpointPasswordlessSessionAuthRequest = {
    session_id: string;
};

type ExplainData = {
    'QUERY PLAN': string;
};

type HealthCheck = {
    /**
     * Service status
     */
    status: string;
};

type StatementData = {
    fields?: Array<string>;
    rows?: Array<Array<string>>;
    truncated: boolean;
};

type StatementResult = {
    data?: StatementData;
    error?: string;
    explain_data?: Array<ExplainData>;
    query: string;
};

export { ApiError, ApiKeyCreateRequest, ApiKeyCreateResponse, ApiKeyRevokeResponse, ApiKeyService, ApiKeysListResponseItem, BaseHttpRequest, Branch, BranchCreateRequest, BranchCreateRequestEndpointOptions, BranchOperations, BranchResponse, BranchService, BranchState, BranchUpdateRequest, BranchesResponse, CancelError, CancelablePromise, ConnectionURI, ConnectionURIResponse, ConnectionURIsResponse, ConsoleSettingsRaw, CurrentUserAuthAccount, CurrentUserInfoResponse, Database, DatabaseCreateRequest, DatabaseOperations, DatabaseResponse, DatabaseUpdateRequest, DatabasesResponse, Duration, EmptyResponse, Endpoint, EndpointCreateRequest, EndpointOperations, EndpointPasswordlessSessionAuthRequest, EndpointPoolerMode, EndpointResponse, EndpointService, EndpointSettingsData, EndpointState, EndpointType, EndpointUpdateRequest, EndpointsResponse, ErrorCode, ExplainData, GeneralError, HealthCheck, NeonClient, OpenAPI, OpenAPIConfig, Operation, OperationAction, OperationResponse, OperationService, OperationStatus, OperationsResponse, Pagination, PaginationResponse, PgSettingsData, PgVersion, Project, ProjectCreateRequest, ProjectOperations, ProjectResponse, ProjectService, ProjectSettings, ProjectSettingsData, ProjectSettingsQuota, ProjectUpdateRequest, ProjectsResponse, Role, RoleCreateRequest, RoleOperations, RolePasswordResponse, RoleResponse, RolesResponse, StatementData, StatementResult };
