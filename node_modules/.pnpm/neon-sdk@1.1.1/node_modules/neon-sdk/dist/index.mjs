// generated/core/BaseHttpRequest.ts
var BaseHttpRequest = class {
  constructor(config) {
    this.config = config;
  }
};

// generated/core/ApiError.ts
var ApiError = class extends Error {
  constructor(request2, response, message) {
    super(message);
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request2;
  }
};

// generated/core/CancelablePromise.ts
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var CancelablePromise = class {
  constructor(executor) {
    this._isResolved = false;
    this._isRejected = false;
    this._isCancelled = false;
    this._cancelHandlers = [];
    this._promise = new Promise((resolve2, reject) => {
      this._resolve = resolve2;
      this._reject = reject;
      const onResolve = (value) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isResolved = true;
        this._resolve?.(value);
      };
      const onReject = (reason) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isRejected = true;
        this._reject?.(reason);
      };
      const onCancel = (cancelHandler) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._cancelHandlers.push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => this._isResolved
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => this._isRejected
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => this._isCancelled
      });
      return executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel() {
    if (this._isResolved || this._isRejected || this._isCancelled) {
      return;
    }
    this._isCancelled = true;
    if (this._cancelHandlers.length) {
      try {
        for (const cancelHandler of this._cancelHandlers) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    this._cancelHandlers.length = 0;
    this._reject?.(new CancelError("Request aborted"));
  }
  get isCancelled() {
    return this._isCancelled;
  }
};
Symbol.toStringTag;

// generated/core/request.ts
var isDefined = (value) => {
  return value !== void 0 && value !== null;
};
var isString = (value) => {
  return typeof value === "string";
};
var isStringWithValue = (value) => {
  return isString(value) && value !== "";
};
var isBlob = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData = (value) => {
  return value instanceof FormData;
};
var base64 = (str) => {
  try {
    return btoa(str);
  } catch (err) {
    return Buffer.from(str).toString("base64");
  }
};
var getQueryString = (params) => {
  const qs = [];
  const append = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          process(key, v);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k, v]) => {
          process(`${key}[${k}]`, v);
        });
      } else {
        append(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl = (config, options) => {
  const encoder = config.ENCODE_PATH || encodeURI;
  const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    if (options.path?.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config.BASE}${path}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
var getFormData = (options) => {
  if (options.formData) {
    const formData = new FormData();
    const process = (key, value) => {
      if (isString(value) || isBlob(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => process(key, v));
      } else {
        process(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders = async (config, options) => {
  const token = await resolve(options, config.TOKEN);
  const username = await resolve(options, config.USERNAME);
  const password = await resolve(options, config.PASSWORD);
  const additionalHeaders = await resolve(options, config.HEADERS);
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers
  }).filter(([_, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({
    ...headers2,
    [key]: String(value)
  }), {});
  if (isStringWithValue(token)) {
    headers["Authorization"] = `Bearer ${token}`;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob(options.body)) {
      headers["Content-Type"] = options.body.type || "application/octet-stream";
    } else if (isString(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return new Headers(headers);
};
var getRequestBody = (options) => {
  if (options.body) {
    if (options.mediaType?.includes("/json")) {
      return JSON.stringify(options.body);
    } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
      return options.body;
    } else {
      return JSON.stringify(options.body);
    }
  }
  return void 0;
};
var sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
  const controller = new AbortController();
  const request2 = {
    headers,
    body: body ?? formData,
    method: options.method,
    signal: controller.signal
  };
  if (config.WITH_CREDENTIALS) {
    request2.credentials = config.CREDENTIALS;
  }
  onCancel(() => controller.abort());
  return await fetch(url, request2);
};
var getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers.get(responseHeader);
    if (isString(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody = async (response) => {
  if (response.status !== 204) {
    try {
      const contentType = response.headers.get("Content-Type");
      if (contentType) {
        const isJSON = contentType.toLowerCase().startsWith("application/json");
        if (isJSON) {
          return await response.json();
        } else {
          return await response.text();
        }
      }
    } catch (error) {
      console.error(error);
    }
  }
  return void 0;
};
var catchErrorCodes = (options, result) => {
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request = (config, options) => {
  return new CancelablePromise(async (resolve2, reject, onCancel) => {
    try {
      const url = getUrl(config, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config, options);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
        const responseBody = await getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);
        const result = {
          url,
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody
        };
        catchErrorCodes(options, result);
        resolve2(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

// generated/core/FetchHttpRequest.ts
var FetchHttpRequest = class extends BaseHttpRequest {
  constructor(config) {
    super(config);
  }
  /**
   * Request method
   * @param options The request options from the service
   * @returns CancelablePromise<T>
   * @throws ApiError
   */
  request(options) {
    return request(this.config, options);
  }
};

// generated/services/ApiKeyService.ts
var ApiKeyService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Get a list of API keys
   * Retrieves the API keys for your Neon account.
   * The response does not include API key tokens. A token is only provided when creating an API key.
   * API keys can also be managed in the Neon Console.
   * For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
   *
   * @returns ApiKeysListResponseItem Returned the API keys for the Neon account
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listApiKeys() {
    return this.httpRequest.request({
      method: "GET",
      url: "/api_keys"
    });
  }
  /**
   * Create an API key
   * Creates an API key.
   * The `key_name` is a user-specified name for the key.
   * This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API.
   * API keys can also be managed in the Neon Console.
   * See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
   *
   * @param requestBody
   * @returns ApiKeyCreateResponse Created an API key
   * @returns GeneralError General Error
   * @throws ApiError
   */
  createApiKey(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/api_keys",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Revoke an API key
   * Revokes the specified API key.
   * An API key that is no longer needed can be revoked.
   * This action cannot be reversed.
   * You can obtain `key_id` values by listing the API keys for your Neon account.
   * API keys can also be managed in the Neon Console.
   * See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
   *
   * @param keyId The API key ID
   * @returns ApiKeyRevokeResponse Revoked the specified API key
   * @returns GeneralError General Error
   * @throws ApiError
   */
  revokeApiKey(keyId) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/api_keys/{key_id}",
      path: {
        "key_id": keyId
      }
    });
  }
};

// generated/services/BranchService.ts
var BranchService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Create a branch
   * Creates a branch in the specified project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   *
   * This method does not require a request body, but you can specify one to create an endpoint for the branch or to select a non-default parent branch.
   * The default behavior is to create a branch from the project's root branch (`main`) with no endpoint, and the branch name is auto-generated.
   * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @param requestBody
   * @returns GeneralError General Error
   * @returns any Created a branch. An endpoint is only created if it was specified in the request.
   * @throws ApiError
   */
  createProjectBranch(projectId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/branches",
      path: {
        "project_id": projectId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get a list of branches
   * Retrieves a list of branches for the specified project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   *
   * Each Neon project has a root branch named `main`.
   * A `branch_id` value has a `br-` prefix.
   * A project may contain child branches that were branched from `main` or from another branch.
   * A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch.
   * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @returns BranchesResponse Returned a list of branches for the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectBranches(projectId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches",
      path: {
        "project_id": projectId
      }
    });
  }
  /**
   * Get branch details
   * Retrieves information about the specified branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain a `branch_id` by listing the project's branches.
   * A `branch_id` value has a `br-` prefix.
   *
   * Each Neon project has a root branch named `main`.
   * A project may contain child branches that were branched from `main` or from another branch.
   * A parent branch is identified by a `parent_id` value, which is the `id` of the parent branch.
   * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @returns BranchResponse Returned information about the specified branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProjectBranch(projectId, branchId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      }
    });
  }
  /**
   * Delete a branch
   * Deletes the specified branch from a project, and places
   * all endpoints into an idle state, breaking existing client connections.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain a `branch_id` by listing the project's branches.
   * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * When a successful response status is received, the endpoints are still active,
   * and the branch is not yet deleted from storage.
   * The deletion occurs after all operations finish.
   * You cannot delete a branch if it is the only remaining branch in the project.
   * A project must have at least one branch.
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @returns BranchOperations Deleted the specified branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  deleteProjectBranch(projectId, branchId) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/projects/{project_id}/branches/{branch_id}",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      }
    });
  }
  /**
   * Update a branch
   * Updates the specified branch. Only changing the branch name is supported.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param requestBody
   * @returns BranchOperations Updated the specified branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  updateProjectBranch(projectId, branchId, requestBody) {
    return this.httpRequest.request({
      method: "PATCH",
      url: "/projects/{project_id}/branches/{branch_id}",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Set the branch as the primary branch of a project
   * The primary mark is automatically removed from the previous primary branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @returns BranchOperations Updated the specified branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  setPrimaryProjectBranch(projectId, branchId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/branches/{branch_id}/set_as_primary",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      }
    });
  }
  /**
   * Get a list of branch endpoints
   * Retrieves a list of endpoints for the specified branch.
   * Currently, Neon permits only one endpoint per branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @returns EndpointsResponse Returned a list of endpoints for the specified branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectBranchEndpoints(projectId, branchId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}/endpoints",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      }
    });
  }
  /**
   * Get a list of databases
   * Retrieves a list of databases for the specified branch.
   * A branch can have multiple databases.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @returns DatabasesResponse Returned a list of databases of the specified branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectBranchDatabases(projectId, branchId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}/databases",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      }
    });
  }
  /**
   * Create a database
   * Creates a database in the specified branch.
   * A branch can have multiple databases.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param requestBody
   * @returns GeneralError General Error
   * @returns DatabaseOperations Created a database in the specified branch
   * @throws ApiError
   */
  createProjectBranchDatabase(projectId, branchId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/branches/{branch_id}/databases",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get database details
   * Retrieves information about the specified database.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` and `database_name` by listing branch's databases.
   * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param databaseName The database name
   * @returns DatabaseResponse Returned the database details
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProjectBranchDatabase(projectId, branchId, databaseName) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}/databases/{database_name}",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "database_name": databaseName
      }
    });
  }
  /**
   * Update a database
   * Updates the specified database in the branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` and `database_name` by listing the branch's databases.
   * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param databaseName The database name
   * @param requestBody
   * @returns DatabaseOperations Updated the database
   * @returns GeneralError General Error
   * @throws ApiError
   */
  updateProjectBranchDatabase(projectId, branchId, databaseName, requestBody) {
    return this.httpRequest.request({
      method: "PATCH",
      url: "/projects/{project_id}/branches/{branch_id}/databases/{database_name}",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "database_name": databaseName
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Delete a database
   * Deletes the specified database from the branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` and `database_name` by listing branch's databases.
   * For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param databaseName The database name
   * @returns DatabaseOperations Deleted the specified database
   * @returns GeneralError General Error
   * @throws ApiError
   */
  deleteProjectBranchDatabase(projectId, branchId, databaseName) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/projects/{project_id}/branches/{branch_id}/databases/{database_name}",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "database_name": databaseName
      }
    });
  }
  /**
   * Get a list of roles
   * Retrieves a list of roles from the specified branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * In Neon, the terms "role" and "user" are synonymous.
   * For related information, see [Manage users](https://neon.tech/docs/manage/users/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @returns RolesResponse Returned a list of roles from the specified branch.
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectBranchRoles(projectId, branchId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}/roles",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      }
    });
  }
  /**
   * Create a role
   * Creates a role in the specified branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * In Neon, the terms "role" and "user" are synonymous.
   * For related information, see [Manage users](https://neon.tech/docs/manage/users/).
   *
   * Connections established to the active read-write endpoint will be dropped.
   * If the read-write endpoint is idle, the endpoint becomes active for a short period of time and is suspended afterward.
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param requestBody
   * @returns GeneralError General Error
   * @returns RoleOperations Created a role in the specified branch
   * @throws ApiError
   */
  createProjectBranchRole(projectId, branchId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/branches/{branch_id}/roles",
      path: {
        "project_id": projectId,
        "branch_id": branchId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get role details
   * Retrieves details about the specified role.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * You can obtain the `role_name` by listing the roles for a branch.
   * In Neon, the terms "role" and "user" are synonymous.
   * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param roleName The role name
   * @returns RoleResponse Successfully returned details for the specified role
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProjectBranchRole(projectId, branchId, roleName) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}/roles/{role_name}",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "role_name": roleName
      }
    });
  }
  /**
   * Delete a role
   * Deletes the specified role from the branch.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * You can obtain the `role_name` by listing the roles for a branch.
   * In Neon, the terms "role" and "user" are synonymous.
   * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param roleName The role name
   * @returns RoleOperations Deleted the specified role from the branch
   * @returns GeneralError General Error
   * @throws ApiError
   */
  deleteProjectBranchRole(projectId, branchId, roleName) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/projects/{project_id}/branches/{branch_id}/roles/{role_name}",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "role_name": roleName
      }
    });
  }
  /**
   * Get role password
   * Retrieves password of the specified role if possible.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * You can obtain the `role_name` by listing the roles for a branch.
   * In Neon, the terms "role" and "user" are synonymous.
   * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param roleName The role name
   * @returns RolePasswordResponse Successfully returned password for the specified role
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProjectBranchRolePassword(projectId, branchId, roleName) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reveal_password",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "role_name": roleName
      },
      errors: {
        404: `Role not found`,
        412: `Storing passwords is disabled`
      }
    });
  }
  /**
   * Reset the role password
   * Resets the password for the specified role.
   * Returns a new password and operations. The new password is ready to use when the last operation finishes.
   * The old password remains valid until last operation finishes.
   * Connections to the read-write endpoint are dropped. If idle,
   * the read-write endpoint becomes active for a short period of time.
   *
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain the `branch_id` by listing the project's branches.
   * You can obtain the `role_name` by listing the roles for a branch.
   * In Neon, the terms "role" and "user" are synonymous.
   * For related information, see [Managing users](https://neon.tech/docs/manage/users/).
   *
   * @param projectId The Neon project ID
   * @param branchId The branch ID
   * @param roleName The role nam
   * @returns RoleOperations Reset the passsword for the specified role
   * @returns GeneralError General Error
   * @throws ApiError
   */
  resetProjectBranchRolePassword(projectId, branchId, roleName) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reset_password",
      path: {
        "project_id": projectId,
        "branch_id": branchId,
        "role_name": roleName
      }
    });
  }
};

// generated/services/EndpointService.ts
var EndpointService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Create an endpoint
   * Creates an endpoint for the specified branch.
   * An endpoint is a Neon compute instance.
   * There is a maximum of one endpoint per branch.
   * If the specified branch already has an endpoint, the operation fails.
   *
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain `branch_id` by listing the project's branches.
   * A `branch_id` has a `br-` prefix.
   * Currently, only the `read_write` endpoint type is supported.
   * For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @param requestBody
   * @returns GeneralError General Error
   * @returns EndpointOperations Created an endpoint
   * @throws ApiError
   */
  createProjectEndpoint(projectId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/endpoints",
      path: {
        "project_id": projectId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get a list of endpoints
   * Retrieves a list of endpoints for the specified project.
   * An endpoint is a Neon compute instance.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @returns EndpointsResponse Returned a list of endpoints for the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectEndpoints(projectId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/endpoints",
      path: {
        "project_id": projectId
      }
    });
  }
  /**
   * Get an endpoint
   * Retrieves information about the specified endpoint.
   * An endpoint is a Neon compute instance.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain an `endpoint_id` by listing your project's endpoints.
   * An `endpoint_id` has an `ep-` prefix.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @param endpointId The endpoint ID
   * @returns EndpointResponse Returned information about the specified endpoint
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProjectEndpoint(projectId, endpointId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/endpoints/{endpoint_id}",
      path: {
        "project_id": projectId,
        "endpoint_id": endpointId
      }
    });
  }
  /**
   * Delete an endpoint
   * Delete the specified endpoint.
   * An endpoint is a Neon compute instance.
   * Deleting an endpoint drops existing network connections to the endpoint.
   * The deletion is completed when last operation in the chain finishes successfully.
   *
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain an `endpoint_id` by listing your project's endpoints.
   * An `endpoint_id` has an `ep-` prefix.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @param endpointId The endpoint ID
   * @returns EndpointOperations Deleted the specified endpoint
   * @returns GeneralError General Error
   * @throws ApiError
   */
  deleteProjectEndpoint(projectId, endpointId) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/projects/{project_id}/endpoints/{endpoint_id}",
      path: {
        "project_id": projectId,
        "endpoint_id": endpointId
      }
    });
  }
  /**
   * Update an endpoint
   * Updates the specified endpoint. Currently, only changing the associated branch is supported.
   * The branch that you specify cannot have an existing endpoint.
   *
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain an `endpoint_id` and `branch_id` by listing your project's endpoints.
   * An `endpoint_id` has an `ep-` prefix. A `branch_id` has a `br-` prefix.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * If the returned list of operations is not empty, the endpoint is not ready to use.
   * The client must wait for the last operation to finish before using the endpoint.
   * If the endpoint was idle before the update, the endpoint becomes active for a short period of time,
   * and the control plane suspends it again after the update.
   *
   * @param projectId The Neon project ID
   * @param endpointId The endpoint ID
   * @param requestBody
   * @returns EndpointOperations Updated the specified endpoint
   * @returns GeneralError General Error
   * @throws ApiError
   */
  updateProjectEndpoint(projectId, endpointId, requestBody) {
    return this.httpRequest.request({
      method: "PATCH",
      url: "/projects/{project_id}/endpoints/{endpoint_id}",
      path: {
        "project_id": projectId,
        "endpoint_id": endpointId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Start an endpoint
   * Starts an endpoint. The endpoint is ready to use
   * after the last operation in chain finishes successfully.
   *
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain an `endpoint_id` by listing your project's endpoints.
   * An `endpoint_id` has an `ep-` prefix.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @param endpointId The endpoint ID
   * @returns EndpointOperations Started the specified endpoint
   * @returns GeneralError General Error
   * @throws ApiError
   */
  startProjectEndpoint(projectId, endpointId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/endpoints/{endpoint_id}/start",
      path: {
        "project_id": projectId,
        "endpoint_id": endpointId
      }
    });
  }
  /**
   * Suspend an endpoint
   * Suspend the specified endpoint
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain an `endpoint_id` by listing your project's endpoints.
   * An `endpoint_id` has an `ep-` prefix.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @param endpointId The endpoint ID
   * @returns EndpointOperations Suspended the specified endpoint
   * @returns GeneralError General Error
   * @throws ApiError
   */
  suspendProjectEndpoint(projectId, endpointId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/endpoints/{endpoint_id}/suspend",
      path: {
        "project_id": projectId,
        "endpoint_id": endpointId
      }
    });
  }
};

// generated/services/OperationService.ts
var OperationService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Get operation details
   * Retrieves details for the specified operation.
   * An operation is an action performed on a Neon project resource.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * You can obtain a `operation_id` by listing operations for the project.
   *
   * @param projectId The Neon project ID
   * @param operationId The operation ID
   * @returns OperationResponse Returned details for the specified operation
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProjectOperation(projectId, operationId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/operations/{operation_id}",
      path: {
        "project_id": projectId,
        "operation_id": operationId
      }
    });
  }
  /**
   * Get a list of operations
   * Retrieves a list of operations for the specified Neon project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * The number of operations returned can be large.
   * To paginate the response, issue an initial request with a `limit` value.
   * Then, add the `cursor` value that was returned in the response to the next request.
   *
   * @param projectId The Neon project ID
   * @param cursor Specify the cursor value from the previous response to get the next batch of operations
   * @param limit Specify a value from 1 to 1000 to limit number of operations in the response
   * @returns any Returned a list of operations
   *
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectOperations(projectId, cursor, limit) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/operations",
      path: {
        "project_id": projectId
      },
      query: {
        "cursor": cursor,
        "limit": limit
      }
    });
  }
};

// generated/services/ProjectService.ts
var ProjectService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Get a list of projects
   * Retrieves a list of projects for the Neon account.
   * A project is the top-level object in the Neon object hierarchy.
   * For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
   *
   * @param cursor Specify the cursor value from the previous response to get the next batch of projects.
   * @param limit Specify a value from 1 to 100 to limit number of projects in the response.
   * @returns any Returned a list of projects for the Neon account
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjects(cursor, limit = 10) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects",
      query: {
        "cursor": cursor,
        "limit": limit
      }
    });
  }
  /**
   * Create a project
   * Creates a Neon project.
   * A project is the top-level object in the Neon object hierarchy.
   * Tier limits define how many projects you can create.
   * Neon's Free Tier permits one project per Neon account.
   * For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
   *
   * You can specify a region and PostgreSQL version in the request body.
   * Neon currently supports PostgreSQL 14 and 15.
   * For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
   *
   * @param requestBody
   * @returns GeneralError General Error
   * @returns any Created a project.
   * The project includes a connection URI with a database, password, and role.
   * At least one non-protected role is created with a password.
   * Wait until the operations are finished before attempting to connect to a project database.
   *
   * @throws ApiError
   */
  createProject(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get project details
   * Retrieves information about the specified project.
   * A project is the top-level object in the Neon object hierarchy.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   *
   * @param projectId The Neon project ID
   * @returns ProjectResponse Returned information about the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  getProject(projectId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}",
      path: {
        "project_id": projectId
      }
    });
  }
  /**
   * Update a project
   * Updates the specified project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * Neon permits updating the project name only.
   *
   * @param projectId The Neon project ID
   * @param requestBody
   * @returns ProjectOperations Updated the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  updateProject(projectId, requestBody) {
    return this.httpRequest.request({
      method: "PATCH",
      url: "/projects/{project_id}",
      path: {
        "project_id": projectId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Delete a project
   * Deletes the specified project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * Deleting a project is a permanent action.
   * Deleting a project also deletes endpoints, branches, databases, and users that belong to the project.
   *
   * @param projectId The Neon project ID
   * @returns ProjectResponse Deleted the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  deleteProject(projectId) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/projects/{project_id}",
      path: {
        "project_id": projectId
      }
    });
  }
  /**
   * Get a list of operations
   * Retrieves a list of operations for the specified Neon project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * The number of operations returned can be large.
   * To paginate the response, issue an initial request with a `limit` value.
   * Then, add the `cursor` value that was returned in the response to the next request.
   *
   * @param projectId The Neon project ID
   * @param cursor Specify the cursor value from the previous response to get the next batch of operations
   * @param limit Specify a value from 1 to 1000 to limit number of operations in the response
   * @returns any Returned a list of operations
   *
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectOperations(projectId, cursor, limit) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/operations",
      path: {
        "project_id": projectId
      },
      query: {
        "cursor": cursor,
        "limit": limit
      }
    });
  }
  /**
   * Create a branch
   * Creates a branch in the specified project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   *
   * This method does not require a request body, but you can specify one to create an endpoint for the branch or to select a non-default parent branch.
   * The default behavior is to create a branch from the project's root branch (`main`) with no endpoint, and the branch name is auto-generated.
   * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @param requestBody
   * @returns GeneralError General Error
   * @returns any Created a branch. An endpoint is only created if it was specified in the request.
   * @throws ApiError
   */
  createProjectBranch(projectId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/projects/{project_id}/branches",
      path: {
        "project_id": projectId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get a list of branches
   * Retrieves a list of branches for the specified project.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   *
   * Each Neon project has a root branch named `main`.
   * A `branch_id` value has a `br-` prefix.
   * A project may contain child branches that were branched from `main` or from another branch.
   * A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch.
   * For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
   *
   * @param projectId The Neon project ID
   * @returns BranchesResponse Returned a list of branches for the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectBranches(projectId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/branches",
      path: {
        "project_id": projectId
      }
    });
  }
  /**
   * Get a list of endpoints
   * Retrieves a list of endpoints for the specified project.
   * An endpoint is a Neon compute instance.
   * You can obtain a `project_id` by listing the projects for your Neon account.
   * For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
   *
   * @param projectId The Neon project ID
   * @returns EndpointsResponse Returned a list of endpoints for the specified project
   * @returns GeneralError General Error
   * @throws ApiError
   */
  listProjectEndpoints(projectId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/projects/{project_id}/endpoints",
      path: {
        "project_id": projectId
      }
    });
  }
};

// generated/NeonClient.ts
var NeonClient = class {
  constructor(config, HttpRequest = FetchHttpRequest) {
    this.request = new HttpRequest({
      BASE: config?.BASE ?? "https://console.neon.tech/api/v2",
      VERSION: config?.VERSION ?? "2",
      WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
      CREDENTIALS: config?.CREDENTIALS ?? "include",
      TOKEN: config?.TOKEN,
      USERNAME: config?.USERNAME,
      PASSWORD: config?.PASSWORD,
      HEADERS: config?.HEADERS,
      ENCODE_PATH: config?.ENCODE_PATH
    });
    this.apiKey = new ApiKeyService(this.request);
    this.branch = new BranchService(this.request);
    this.endpoint = new EndpointService(this.request);
    this.operation = new OperationService(this.request);
    this.project = new ProjectService(this.request);
  }
};

// generated/core/OpenAPI.ts
var OpenAPI = {
  BASE: "https://console.neon.tech/api/v2",
  VERSION: "2",
  WITH_CREDENTIALS: false,
  CREDENTIALS: "include",
  TOKEN: void 0,
  USERNAME: void 0,
  PASSWORD: void 0,
  HEADERS: void 0,
  ENCODE_PATH: void 0
};
export {
  ApiError,
  ApiKeyService,
  BaseHttpRequest,
  BranchService,
  CancelError,
  CancelablePromise,
  EndpointService,
  NeonClient,
  OpenAPI,
  OperationService,
  ProjectService
};
